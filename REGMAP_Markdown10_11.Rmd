---
title: "REGMAP_Markdown_06_11"
author: "Mélodie"
date: "06/11/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Introduction

La première étape de notre projet de TER consiste à analyser trois jeux de données phénotypiques sur des arabidopsis pour comprendre comment des conditions de fort CO2 impactent la quantité de nutriments qu'elles produisent. Vous trouverez ci-après l'analyse du deuxième dataset dont nous disposons qui s'appelle REGMAP.

## Données brutes 

Voici les données fournies par nos commanditaires. Nous allons pouvoir leur appliquer plusieurs traitement afin de nous familiariser avec et de visualiser les dynamiques entre les différentes variables observées.

```{r call1, message=FALSE, warning=FALSE, echo=FALSE}
library(tidyr)
library(dplyr)
```
```{r}
reg <- read.table("REGMAP_phenotypes.csv",sep=";",h=TRUE,na.strings = ".")
head(reg)
```

### Suppression des lignes avec des Na

Dans ce dataset nous avions des lignes pour lesquelles il manquait une observation, nous les avons donc supprimées.

```{r}
# supression des colonnes inutiles pour l'instant

reg_no_ch <- subset (reg, select = -c(N_change:Zn_change))
reg_clean = reg_no_ch[-c(17,42),] 
head(reg_clean)

```
## Identification des outliers

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.height=4, fig.width=4}
library(ggplot2)
ggplot(data= reg_clean, aes(x =Fe_aCo2, y = Fe_eCo2))+
  geom_point()+
  geom_abline(a=0, b=1,col="blue")
```
```{r echo=FALSE, message=FALSE, warning=FALSE, fig.height=4, fig.width=4}
library(ggplot2)
ggplot(data= reg_clean, aes(x =Zn_aCo2, y = Zn_eCo2))+
  geom_point()+
  geom_abline(a=0, b=1,col="blue")
```

Comme le montrent ces deux Scatter plots,certaines valeurs pour certains éléments sont très singulières, et après discussion avec nos encadrants nous en avons conclu qu'il s'agit d'erreurs de mesures qui ne peuvent pas exister en réalité. Nous allons donc les supprimer.

## Suppression des outliers

Nous allons maintenant supprimer les outliers en choisissant d'enlever les lignes contenant des valeurs plus de trois fois plus grandes que la médiane. Nous avons choisi la médiane et non l'écart type car les valeurs des outliers ont moins d'influence sur elle.

```{r message=FALSE, warning=FALSE}
reg_no_out <- reg_clean
k= 3
for (i in 2:17) {
  binf <- median(reg_clean[,i]) - k* mad(reg_clean[,i])
  bsup <- median(reg_clean[,i]) + k* mad(reg_clean[,i])
  outlier_idx <- which(reg_no_out[,i] < binf | reg_no_out[,i] > bsup)
    if (length(outlier_idx) == 0) {
      reg_no_out = reg_no_out
    }
    else{
      reg_no_out = reg_no_out[-c(outlier_idx),]
      }
  print(outlier_idx)
  }
  
```

On passe donc de 200 à 110 plantes, en enlevant les lignes avec des Na et les outliers

### Calcul des colonnes de variation sans les outliers

Comme nous avons supprimé les lignes contenant des outliers, ils nous faut recalculer les colonnes de variation pour chaque élément, ce qui nous donne ce nouveau DataFrame : 

```{r message=FALSE, warning=FALSE, echo = FALSE}
library(tidyverse)

reg_no_out_ch <- reg_no_out

reg_no_out_ch <- mutate(reg_no_out_ch,N_change = round(((reg_no_out$N_eCo2-reg_no_out$N_aCo2)/reg_no_out$N_aCo2)*100, digits = 2)
)

reg_no_out_ch <- mutate(reg_no_out_ch,Fe_change = round(((reg_no_out$Fe_eCo2-reg_no_out$Fe_aCo2)/reg_no_out$Fe_aCo2)*100, digits = 2)
)

reg_no_out_ch <- mutate(reg_no_out_ch,Mg_change = round(((reg_no_out$Mg_eCo2-reg_no_out$Mg_aCo2)/reg_no_out$Mg_aCo2)*100, digits = 2)
)

reg_no_out_ch <- mutate(reg_no_out_ch,Mn_change = round(((reg_no_out$Mn_eCo2-reg_no_out$Mn_aCo2)/reg_no_out$Mn_aCo2)*100, digits = 2)
)

reg_no_out_ch <- mutate(reg_no_out_ch,Na_change = round(((reg_no_out$Na_eCo2-reg_no_out$Na_aCo2)/reg_no_out$Na_aCo2)*100, digits = 2)
)

reg_no_out_ch <- mutate(reg_no_out_ch,Zn_change = round(((reg_no_out$Zn_eCo2-reg_no_out$Zn_aCo2)/reg_no_out$Zn_aCo2)*100, digits = 2)
)

reg_no_out_ch <- mutate(reg_no_out_ch,C_change = round(((reg_no_out$C_eCo2-reg_no_out$C_aCo2)/reg_no_out$C_aCo2)*100, digits = 2)
)

reg_no_out_ch <- mutate(reg_no_out_ch,Cu_change = round(((reg_no_out$Cu_eCo2-reg_no_out$Cu_aCo2)/reg_no_out$Cu_aCo2)*100, digits = 2)
)

reg_ch <- select(reg_no_out_ch,"genotype"|contains("change"))

reg_chl <- gather(data = reg_ch, key = "element", value = "valeur", 2:9)


head(reg_no_out_ch)



```
## Première Visualisation : Variation moyenne des mesures entre le aCO2 et le eCO2

Nous avons ici voulu reproduire une visualisation qui avait été faite dans le cas du riz pour montrer la variation de chaque élément quand la plante est en condition de fort CO2 et quand elle est en condition de CO2 ambiant

```{r echo=FALSE, message=FALSE, warning=FALSE}
library(ggplot2)
library(hrbrthemes)
library(viridis)
```

```{r}
ggplot(reg_chl, aes(element, valeur, fill = element))+
  stat_summary(fun = mean, geom = "bar") +
  stat_summary(fun.data = mean_se, geom = "errorbar", width = 0.2)+
  geom_hline(yintercept = 0, color = "red", linetype = "dashed", size = 1) +
  scale_fill_viridis_d() +
  scale_color_viridis_d() +
  theme_bw()
```

Observations : 

1) On n'observe pas vraiment de hausse des taux de Carbonne mesurés (contrairement à ce qui a été vu chez le riz par exemple) mais cela s'explique par le fait que la mesure est rapportée au poids de la plante. Ce résultat est donc plutôt normal.
2) On observe une baisse de Zn,N,Mn,Mg,Cu,Fe et une augmentation de Na.

## Scatter plots

Afin de visualiser d'une autre façon si il y a une perte de certains éléments quand la plante est en condition de fort CO2, nous avons créé des scatter plots.


```{r fig.height=4, fig.width=4}
i = 2
while (i < 17) {
  print(
    ggplot(data= reg_no_out, aes(x =reg_no_out[,i+1], y = reg_no_out[,i]))+
    geom_point()+
    xlab(colnames(reg)[i+1]) + ylab(colnames(reg)[i])+
    geom_abline(slope = 1, intercept = 1,col="blue")
  )
  
i = i + 2}
```

## Distribution des données : Histogrammes et Violin plots

### Violin plots

```{r fig.height=10, fig.width=10, message=FALSE, warning=FALSE, echo = FALSE}
library(reshape2)
library(ggplot2)
library(dplyr)

reg_no_out_no_ch = reg_no_out
reg_long = melt(reg_no_out_no_ch)

ggplot(data= reg_long, aes(x=variable, y=value))+
  geom_violin(aes(fill=variable))+
  geom_jitter(alpha=0.2)+
  facet_wrap(~variable,scales ="free")+
  ggtitle("Violin plots de chaque élément")
 
```

### Histogrammes

```{r fig.height=10, fig.width=10, message=FALSE, warning=FALSE, echo=FALSE}

#print(shapiro.test(reg_no_out[,i]))

ggplot(data= reg_long, aes(x=value))+
  geom_histogram()+
  facet_wrap(~variable,scales ="free")+
  ggtitle("histogramme de chaque élément")

```
```{r}
i = 2
while (i < 18) {
  ggplot(data= reg_no_out_no_ch, aes(sample=reg_no_out_no_ch[,i]))+
    stat_qq()+
    facet_wrap(~reg_no_out_no_ch[,i],scales ="free")+
    ggtitle("qqplot de chaque élément")
  i=i+1
}
```


Après ces deux visualisations nous pouvons remarquer que les distributions ont l'air pour la plupart normales mais que des doutes quand à leur normalité persistent.

## Tests de normalité : Test de Shapiro

Dans le but de choisir des tests sur la moyenne et sur la variance adaptés à nos données, nous avons commencé par réaliser un test de normalité, ici le test de Shapiro.

Voici les p-values pour la distribution de chaque élément : 

```{r echo = FALSE}
i = 2
while (i < 18) {
  print(paste("Test de Shapiro entre les données", names(reg_no_out[i])))
  print(shapiro.test(reg_no_out[,i])$p.value)
  i = i + 1
}
```
Ici, nous remarquons que les éléments dont la distribution suit une loi normale après avoir enlevé les outliers sont : C, Zn_e, Na_e, Mg et Cu, Mn, N_a,

### Test de significativité sur les moyennes : Wilcoxon
Ici on a choisi un test de Wilcoxon (car on ne respecte pas les pré-requis pour un test paramétrique pour toutes nos variables) pour des valeurs paired, car la mesure en Co2 ambiant et élevé sont réalisées sur les mêmes génotypes. Vous trouverez ci dessous des violin plots deux à deux et la p-value de chaque paire avec le test de Wilcoxon.

```{r fig.height=15, fig.width=15, message=FALSE, warning=FALSE}
library(ggplot2)
library(RColorBrewer)
library(ggpubr)

reg_long = melt(reg_no_out_no_ch)
reg_long$element = stringr::str_split_fixed(reg_long$variable, "_",2)[,1]
reg_long$Co2 = stringr::str_split_fixed(reg_long$variable, "_",2)[,2]

nb.cols <- 16
mycolors <- colorRampPalette(brewer.pal(8, "Paired"))(nb.cols)

ggplot(data = reg_long, aes(x = Co2, y = value)) +
  geom_violin(aes(fill = variable), draw_quantiles = c(0.25,0.5,0.75)) +
  facet_wrap( ~ element, scales = "free") +
  scale_fill_manual(values = mycolors) +
  stat_compare_means(paired = TRUE, method = "wilcox")
```

### Autre visualisation du résultat du test de Wilcoxon

```{r fig.height=4, fig.width=4,}
i=2
while (i < 17) {
  plot_paired <- ggpaired(reg_no_out, cond1 = names(reg_no_out[i+1]) , cond2 = names(reg_no_out[i]),
           line.color = "dark gray", line.size = 0.6, color = "condition",
           width = 0.7, linetype = "dotted" ,
           palette = "aas")+
    stat_compare_means(paired = TRUE)
  print(plot_paired)
  i = i+2
}
```

On peut constater en regardant les graphes et le p-values du test de Wilcoxon que les éléments Cu,Fe,Mg,Mn,Na,Zn,C et N ont des moyennent significativement différentes entre CO2 ambiant et élevé, soit tous les éléments.

### Test de significativité sur les moyennes pour les répartitions normales : Student

```{r echo = FALSE}

  print("Test de Student entre les données Mg_aCo2 et Mg_eCo2")
  print(paste("p-value = ",t.test(reg_no_out$Mg_aCo2, reg_no_out$Mg_eCo2, paired = TRUE)$p.value))
  
  print("Test de Student entre les données Mn_aCo2 et Mn_eCo2")
  print(paste("p-value = ",t.test(reg_no_out$Mn_aCo2, reg_no_out$Mn_eCo2, paired = TRUE)$p.value))
   
  print("Test de Student entre les données Cu_aCo2 et Cu_eCo2")
  print(paste("p-value = ",t.test(reg_no_out$Cu_aCo2, reg_no_out$Cu_eCo2, paired = TRUE)$p.value))
  
```

Ici, on observe que tous les éléments de distribution normales ont une moyenne significativement différente.
Nous sommes donc encore plus assurés que les moyennes sont significativement différentes, même pour les éléements aux distributions normales.


### Test de significativité sur les variances pour les répartitions non normales : Levene


```{r echo = FALSE}
library(lawstat)
i = 2
while (i < 17) {
  print(paste("Test de Levene entre les données", names(reg_no_out[i]), "et", names(reg_no_out[i+1])))
  a = reg_no_out[,i+1]
  e = reg_no_out[,i]
  values = c(a,e)
  factor = c(rep('aCo2',length(a)), rep('eCo2',length(e)))
  print(paste("p-value = ",levene.test(values, factor)$p.value))
  i = i + 2
}

```
### Test de significativité sur les variances pour les répartitions normales : Fisher
```{r echo = FALSE}

  print("Test de Fisher entre les données Mg_aCo2 et Mg_eCo2")
  print(paste("p-value = ",var.test(reg_no_out$Mg_aCo2, reg_no_out$Mg_eCo2, paired = TRUE)$p.value))
  
  print("Test de Fisher entre les données Mn_aCo2 et Mn_eCo2")
  print(paste("p-value = ",var.test(reg_no_out$Mn_aCo2, reg_no_out$Mn_eCo2, paired = TRUE)$p.value))
   
  print("Test de Fisher entre les données Cu_aCo2 et Cu_eCo2")
  print(paste("p-value = ",var.test(reg_no_out$Cu_aCo2, reg_no_out$Cu_eCo2, paired = TRUE)$p.value))
  
```

Confirment que ces éléments n'ont pas une variance significativement différente